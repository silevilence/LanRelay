@* File transfer bubble component for displaying file messages in chat *@
@implements IDisposable

<div class="file-bubble @(IsOutgoing ? "outgoing" : "incoming")">
    <div class="file-icon">
        @GetFileIcon()
    </div>
    <div class="file-info">
        <div class="file-name" title="@FileName">@FileName</div>
        <div class="file-size">@FormatFileSize(FileSize)</div>
        
        @switch (Status)
        {
            case TransferStatus.Pending when !IsOutgoing:
                <div class="file-actions">
                    <button class="btn-accept" @onclick="HandleAccept" title="æ¥æ”¶">âœ“</button>
                    <button class="btn-reject" @onclick="HandleReject" title="æ‹’ç»">âœ—</button>
                </div>
                break;
                
            case TransferStatus.Pending when IsOutgoing:
                <div class="file-status">ç­‰å¾…å¯¹æ–¹æ¥æ”¶...</div>
                break;
                
            case TransferStatus.InProgress:
                <div class="progress-container">
                    <div class="progress-bar" style="width: @(Progress * 100)%"></div>
                </div>
                <div class="progress-text">@((Progress * 100).ToString("F0"))%</div>
                break;
                
            case TransferStatus.Completed:
                <div class="file-status completed">âœ“ ä¼ è¾“å®Œæˆ</div>
                break;
                
            case TransferStatus.Cancelled:
                <div class="file-status cancelled">å·²å–æ¶ˆ</div>
                break;
                
            case TransferStatus.Rejected:
                <div class="file-status rejected">å·²æ‹’ç»</div>
                break;
                
            case TransferStatus.Failed:
                <div class="file-status failed">ä¼ è¾“å¤±è´¥</div>
                break;
        }
    </div>
    <div class="bubble-time">
        @Timestamp.ToString("HH:mm")
    </div>
</div>

@code {
    [Parameter, EditorRequired]
    public Guid TransferId { get; set; }

    [Parameter, EditorRequired]
    public string FileName { get; set; } = "";

    [Parameter, EditorRequired]
    public long FileSize { get; set; }

    [Parameter]
    public bool IsOutgoing { get; set; }

    [Parameter]
    public TransferStatus Status { get; set; }

    [Parameter]
    public double Progress { get; set; }

    [Parameter]
    public DateTime Timestamp { get; set; }

    [Parameter]
    public EventCallback<Guid> OnAccept { get; set; }

    [Parameter]
    public EventCallback<Guid> OnReject { get; set; }

    private string GetFileIcon()
    {
        var ext = Path.GetExtension(FileName).ToLowerInvariant();
        return ext switch
        {
            ".pdf" => "ğŸ“„",
            ".doc" or ".docx" => "ğŸ“",
            ".xls" or ".xlsx" => "ğŸ“Š",
            ".ppt" or ".pptx" => "ğŸ“½ï¸",
            ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" => "ğŸ–¼ï¸",
            ".mp3" or ".wav" or ".flac" => "ğŸµ",
            ".mp4" or ".avi" or ".mkv" or ".mov" => "ğŸ¬",
            ".zip" or ".rar" or ".7z" or ".tar" or ".gz" => "ğŸ“¦",
            ".exe" or ".msi" => "âš™ï¸",
            ".txt" => "ğŸ“ƒ",
            _ => "ğŸ“"
        };
    }

    private static string FormatFileSize(long bytes)
    {
        string[] sizes = ["B", "KB", "MB", "GB", "TB"];
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private async Task HandleAccept()
    {
        await OnAccept.InvokeAsync(TransferId);
    }

    private async Task HandleReject()
    {
        await OnReject.InvokeAsync(TransferId);
    }

    public void Dispose()
    {
        // Cleanup if needed
    }
}
